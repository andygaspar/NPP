import numpy as np

from Genetic.genetic_old import GeneticOld
from Instance.instance import Instance

n_paths = 56
n_commodities = 56
run = 1

npp = Instance(n_paths=n_paths, n_commodities=n_commodities, seeds=run)

sol = np.random.uniform(size=n_paths) * npp.upper_bounds



genetic = GeneticOld(population_size=128, pso_population=32, npp=npp,
                     mutation_rate=0.02,
                     fitness_fun=npp.compute_solution_value, offspring_rate=0.5, n_threads=8)

sols = np.zeros((36, npp.n_paths))
for i in range(36):
    genetic.run(1000, 4, 15000, 1, 150, 32, 3,
            True)
    sols[i] = genetic.population[0]


genetic = GeneticOld(population_size=36, pso_population=32, npp=npp,
                     mutation_rate=0.02,
                     fitness_fun=npp.compute_solution_value, offspring_rate=0.5, n_threads=8)
genetic.run(2000, 4, 15000, 1, 150, 32, 3,
            True, sols)


init = np.random.uniform(size=n_paths) * npp.upper_bounds
genetic = GeneticOld(population_size=36, pso_population=32, npp=npp,
                     mutation_rate=0.02,
                     fitness_fun=npp.compute_solution_value, offspring_rate=0.5, n_threads=8)
genetic.run(1, 36, 0, 2000, 15000, 32, 2000,
            True, init)
genetic = GeneticOld(population_size=36, pso_population=32, npp=npp,
                     mutation_rate=0.02,
                     fitness_fun=npp.compute_solution_value, offspring_rate=0.5, n_threads=1)
genetic.run(2000, 4, 15000, 1, 150, 32, 3,
            True, init)

old_bests = [npp.compute_solution_value(s) for s in sols]
max(old_bests)
init_sol = genetic.population[0]
best_val = npp.compute_solution_value(init_sol)

sol = init_sol.copy()
print(best_val)


init_sol = genetic.population[0]
best_val = npp.compute_solution_value(init_sol)


print(best_val)
idxs = np.argsort(npp.n_users)[::-1]
old_bests = [npp.compute_solution_value(s) for s in sols]
new_bests = [val for val in old_bests]
solsdd = genetic.population
for i, s in enumerate(solsdd[:1]):
    sol = s.copy()
    improving = True
    current_best = old_bests[i]
    while improving:
        for idx in idxs:
            sub_improving = True
            new_sol = sol.copy()
            while sub_improving:
                new_sol[idx] += 0.01
                val = npp.compute_solution_value(new_sol)
                if val > current_best:
                    sol = new_sol
                    current_best = val
                else:
                    sub_improving = False
        if current_best > best_val:
            best_val = current_best
        else:
            improving = False
    new_bests[i] = current_best


solutions = np.array([new_bests, old_bests])
print(best_val, max(new_bests))
genetic.best_val
new_sol - genetic.population[0]

init_sol = genetic.population[0]
best_val = npp.compute_solution_value(init_sol)
best_val